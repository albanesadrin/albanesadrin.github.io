<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Arbre procédural</title>
    <style>
        body {
            margin: 0;
        }
    </style>
</head>

<body>
    <script>
        function createRandomGenerator(seed) {
            const constant = Math.pow(2, 13) + 1;
            const prime = 1987;
            const range = Math.pow(2, 50);
            let x = stringToNumberHash(seed) % range;

            return function () {
                x = (constant * x + prime) % range;
                return x / range;
            }
        }

        function stringToNumberHash(str) {
            let hash = 0;
            if (str.length === 0) {
                return hash;
            }
            for (let i = 0; i < str.length; i++) {
                const char = str.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash |= 0; // Convertit en entier 32 bits
            }
            return Math.abs(hash);
        }
        

        // Définition de la graine
        const seed = 'fpfuyb';

        // Création de la fonction de pseudogénération
        const seedRandom = createRandomGenerator(seed);
        // seedRandom('init')

        // Définition des constantes
        const AVAILABLE_SKY_COLORS = ['#82AAE3', '#91D8E4', '#BFEAF5', '#EAFDFC', '#B9F3FC', '#AEE2FF', '#93C6E7', '#93C6E7', '#FEDEFF', '#6E85B7', '#B2C8DF', '#C4D7E0', '#FFC18E', '#CA4E79', '#7A4069', '#513252'];
        const AVAILABLE_BRANCH_COLORS = ['#A9907E', '#F3DEBA', '#675D50', '#A75D5D', '#473C33', '#4C4B16', '#AA8B56', '#665A48', '#61481C', '#A97155', '#663300'];
        const AVAILABLE_LEAF_COLORS = ['#ABC4AA', '#F7DB6A', '#EBB02D', '#AEC2B6', '#FC7300', '#D3756B', '#BFDB38', '#609966', '#82CD47', '#379237', '#F8C4B4', '#FFAE6D', '#007700'];

        // Définition des paramètres de l'arbre
        const maxDepth = 12; // Profondeur maximale de l'arbre
        const branchLength = 40; // Longueur maximale des branches
        const branchAngle = Math.PI / 2; // Angle de séparation des branches
        const branchThickness = 20; // Épaisseur de la branche principale
        const branchColor = AVAILABLE_BRANCH_COLORS[Math.round(seedRandom('branches') * AVAILABLE_BRANCH_COLORS.length)]; // Couleur de la branche principale
        const branchColorVariation = 20; // Variation de la couleur de la branche
        const branchLengthVariation = 0.9; // Variation de la longueur des branches
        const branchAngleVariation = Math.PI / 14; // Variation de l'angle de séparation des branches
        const branchThicknessVariation = 0.6; // Variation de l'épaisseur des branches (0.5 = très varié, 1 = aucune variation)
        const leafProbability = 0.9; // Probabilité de dessiner une feuille à l'extrémité d'une branche
        const leafSize = 5; // Taille des feuilles
        const leafColor = AVAILABLE_LEAF_COLORS[Math.round(seedRandom('leaves') * AVAILABLE_LEAF_COLORS.length)]; // Couleur des feuilles

        // Définition des paramètres extérieurs
        // On veut une valeur de probabilité différente chaque jour, or seedRandom() donne la même valeur peu importe ce qu'on lui passe
        // Ceci est du au fait l'algorithme (bancal) donne des valeurs qui dépendent du nombre de fois où la fonction a été appelée
        // Solution de contournement : on appelle seedRandom() une fois de plus qu'hier pour obtenir un chiffre différent
        const EVE = new Date(0);
        let TODAY = new Date();
        TODAY = new Date(TODAY.setDate(TODAY.getDate() + 0))
        const diffInDays = Math.round(Math.abs(TODAY - EVE) / 1000 / 60 / 60 / 24)
        for(let day = 0; day < diffInDays; day++) {
            seedRandom(TODAY.getTime())
        }
        const WIND_ANGLE = Math.PI / 64;
        const WIND_SPEED = 0.05;
        const SKY_COLOR = AVAILABLE_SKY_COLORS[Math.round(seedRandom(TODAY.getTime()) * AVAILABLE_SKY_COLORS.length)];

        // Création du canvas
        const canvas = document.createElement("canvas");
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        document.body.appendChild(canvas);

        // Récupération du contexte de rendu
        const context = canvas.getContext("2d");

        // Dessin du décor
        context.fillStyle = SKY_COLOR;
        context.fillRect(0, 0, canvas.width, canvas.height);

        // Fonction pour dessiner une feuille à une position donnée
        function drawLeaf(x, y) {
            context.beginPath();
            context.ellipse(
                x,
                y,
                leafSize,
                leafSize * 2,
                seedRandom(y) * 360,
                0,
                2 * Math.PI
            );
            context.fillStyle = leafColor;
            context.fill();
        }

        // Fonction récursive pour dessiner l'arbre
        function drawTree(x, y, angle, depth, thickness, curveControlPointX = x, curveControlPointY = y) {
            // Dessiner la branche principale
            context.beginPath();
            context.moveTo(x, y);
            const endX = x + Math.cos(angle) * (branchLength * (seedRandom(x) * branchLengthVariation + 1));
            const endY = y + Math.sin(angle) * (branchLength * (seedRandom(y) * branchLengthVariation + 1));
            const branchColorHue = parseInt(branchColor.substring(1), 16);
            const branchColorVariationHue = Math.floor(seedRandom(x) * branchColorVariation * 2) - branchColorVariation;
            const branchColorHueWithVariation = (branchColorHue + branchColorVariationHue) % 360;
            const branchColorWithVariation = `hsl(${branchColorHueWithVariation}, 50%, 30%)`;
            context.quadraticCurveTo(curveControlPointX, curveControlPointY, endX, endY);
            context.strokeStyle = branchColorWithVariation;
            context.lineWidth = thickness;
            context.stroke();

            // Dessiner une feuille
            const leafDice = seedRandom(x) - (depth - maxDepth) / 10;

            if (leafDice < leafProbability) {
                drawLeaf(endX, endY);
            }

            if (depth < maxDepth) {
                // Dessiner les branches suivantes
                const dx1 = endX + Math.cos(angle + branchAngle * (seedRandom(endX) * branchAngleVariation)) * (branchLength * (seedRandom(endX) * branchLengthVariation + 1));
                const dy1 = endY + Math.sin(angle + branchAngle * (seedRandom(endY) * branchAngleVariation)) * (branchLength * (seedRandom(endY) * branchLengthVariation + 1));
                const dx2 = endX + Math.cos(angle - branchAngle * (seedRandom(endX + 1) * branchAngleVariation)) * (branchLength * (seedRandom(endX + 1) * branchLengthVariation + 1));
                const dy2 = endY + Math.sin(angle - branchAngle * (seedRandom(endY + 1) * branchAngleVariation)) * (branchLength * (seedRandom(endY + 1) * branchLengthVariation + 1));
                const thicknessDice1 = thickness * (seedRandom(endX) * (1 - branchThicknessVariation) + branchThicknessVariation);
                const thicknessDice2 = thickness * (seedRandom(endX + 1) * (1 - branchThicknessVariation) + branchThicknessVariation);
                const thickness1 = thicknessDice1 < branchThickness ? thicknessDice1 : branchThickness;
                const thickness2 = thicknessDice2 < branchThickness ? thicknessDice2 : branchThickness;
                drawTree(endX, endY, angle + branchAngleVariation, depth + 1, thickness1, dx1, dy1);
                drawTree(endX, endY, angle - branchAngleVariation, depth + 1, thickness2, dx2, dy2);
            }
            // (Math.random() * WIND_ANGLE - WIND_ANGLE / 2)
        }

        // Fonction d'animation de l'arbre avec le vent
        function animateTree() {
            // Effacer le canevas
            context.clearRect(0, 0, canvas.width, canvas.height);

            // Calculer le nouvel angle du vent
            const windAngle = Math.sin(Date.now() * WIND_SPEED) * WIND_ANGLE;

            // Dessiner l'arbre avec l'angle du vent
            drawTree(canvas.width / 2, canvas.height, (-Math.PI / 2) + windAngle, 0, branchThickness);

            // Planifier la prochaine animation
            setTimeout(() => {
                requestAnimationFrame(animateTree);
            }, 1000 / 1)
        }

        //animateTree();
        drawTree(canvas.width / 2, canvas.height, -Math.PI / 2, 0, branchThickness);
    </script>
</body>

</html>